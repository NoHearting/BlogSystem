package com.example.backgroundsystem;

public class Datas {

    public static final String[] datas = {"# <center>应用层</center>\n" +
            "### <font color=\"#ce58f2\" >主要内容</font>\n" +
            "\n" +
            "* 6.1 [域名系统DNS](#name)\n" +
            "* 6.2 [文件传输协议](#file)\n" +
            "* 6.3 [远程终端协议 TELNET（telnet）](#telnet)\n" +
            "* 6.4 [万维网 WWW](#www)\n" +
            "* 6.5 [电子邮件](#email)\n" +
            "* 6.6 [动态主机配置协议DHCP](#dhcp)\n" +
            "* 6.7 [简单网络管理协议SNMP](#snmp)\n" +
            "\n" +
            "## <span id=\"name\">域名系统DNS</span>\n" +
            ">**域名系统**DNS（Domain Name System）是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址\n" +
            "\n" +
            "* 域名到IP地址的解析过程要点如下：\n" +
            "  当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个用户，把待解析的域名放在DNS请求报文中，以**UDP用户数据报**的方式发送给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。\n" +
            "* 域名的命名方法：\n" +
            "  - 采用层次树桩结构的命名方法，采用这种命名方法，任何一个连接在互联网上的主机或路由器，都有一个唯一的**层次结构的名字**，即**域名**。\n" +
            "  - 从语法上讲，每一个域名都由**标号**序列组成，而各标号之间用**点**隔开。例如：\n" +
            "      ```\n" +
            "      mail.cctv.com\n" +
            "      三级域名.二级域名.顶级域名\n" +
            "      ```\n" +
            "  - DNS规定，域名中的标号都由英文和数字组成，**每一个标号不超过63个字符，也不区分大小写字母**\n" +
            "  - 标号中除连字符（-）外不能使用其他标点符号。\n" +
            "  - 级别最低的域名写在最左边，而级别最高的域名写在最右边。\n" +
            "  - 由多个标号组成的完整域名总共不超过255个字符。\n" +
            "* 顶级域名的分类：\n" +
            "  - 国家顶级域名nTLD\n" +
            "    * cn表示中国\n" +
            "    * us表示美国\n" +
            "    * uk表示英国\n" +
            "    * ····\n" +
            "  - 通用顶级域名gTLD\n" +
            "    * com表示公司企业\n" +
            "    * net网络服务机构\n" +
            "    * org非营利性组织\n" +
            "    * ····\n" +
            "  - 基础结构域名\n" +
            "    * arpa，用于反向域名解析，因此又称为**反向域名**\n" +
            "* 域名服务器\n" +
            "  >一个域名服务器所负责管辖范围叫做区。每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到IP地址的映射。区是DNS服务器实际管辖的范围。区可能等于或小于域，但一定不能大于域。\n" +
            "\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191226172142899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  - 域名服务器分类：\n" +
            "    + 根域名服务器\n" +
            "    根域名服务器是最高层次的服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。\n" +
            "    + 顶级域名服务器\n" +
            "    这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答。\n" +
            "    + 权限域名服务器\n" +
            "    负责一个区的域名服务器。\n" +
            "    + 本地域名服务器\n" +
            "    本地域名服务器并不属于上图所示的域名服务器层次结构。但一台主机发出DNS查询请求时，这个查询请求就发送给本地域名服务器。\n" +
            "  - 域名解析的过程\n" +
            "    + 递归查询\n" +
            "    主机向本地域名服务器的查询一般都是采用递归查询。\n" +
            "    所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机进行下一步查询。\n" +
            "    + 迭代查询\n" +
            "    本地域名服务器向根域名服务器的查询通常是采用迭代查询。\n" +
            "    所谓迭代查询就是：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出查询的IP地址，要么告诉本地域名服务器：下一步应当向哪一个域名服务器进行查询。\n" +
            "  - 域名服务器中的高速缓存\n" +
            "    为了提高DNS查询效率，并减轻根域名服务器的负荷和减少互联网上的DNS服务器查询报文，在域名服务器中广泛的使用的高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n" +
            "## <span id=\"file\">文件传输协议</span>\n" +
            "* 文件传送协议FTP\n" +
            "  >FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASSII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的授权）。\n" +
            "\n" +
            "  - 熟知端口号为21\n" +
            "  - FTP是基于TCP的协议，其特点是：\n" +
            "  若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。\n" +
            "  - FTP的主要功能：\n" +
            "  减少或消除在不同操作系统下处理文件的不兼容性\n" +
            "  - FTP的服务器进程的组成\n" +
            "    1. 一个主进程，负责接收新的请求\n" +
            "    2. 若干个从属进程，负责处理单个请求。\n" +
            "  - FTP进行传送文件的时候要建立两个并行的TCP连接：\n" +
            "    1. 控制连接\n" +
            "      控制连接在整个会话期间一直保持打开，FTP客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制进程并不传送文件。\n" +
            "    2. 数据连接\n" +
            "      服务器端控制进程在收到FTP客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。\n" +
            "  - FTP的缺点\n" +
            "    加入计算机A需要在计算机B上很大的一个文件末尾添加一行信息，必须先将此文件传送到A，添加后又传送回B。效率很低。\n" +
            "\n" +
            "* 简单文件传输协议TFTP\n" +
            "  >它是一个很小且易于实现的文件传送协议。TFTP也是用CS模式，但是TFTP基于UDP，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。TFTP没有庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别\n" +
            "\n" +
            "  - 熟知端口号为69\n" +
            "  - TFTP的优点\n" +
            "    1. TFTP可用于UDP环境\n" +
            "    2. TFTP代码所占内存较小\n" +
            "  - TFTP的主要特点\n" +
            "    1. 每次传送的数据报文中有512字节的数据，但最后一次可不足512字节\n" +
            "    2. 数据报按序号编号，从1开始\n" +
            "    3. 支持ASCII码或二进制传送\n" +
            "    4. 可对文件进行读或写\n" +
            "    5. 使用很简单的首部\n" +
            "## <span id=\"telnet\">远程终端协议TELNET</span>\n" +
            ">TELNET是一个简单的远程终端协议，它也是互联网的正式标准。用户用TELNET就可在其所在地通过TCP连接注册到远程的另一台主机上。\n" +
            "\n" +
            "* 现在随着计算机功能越来越强，用户已经很少使用TELNET了。\n" +
            "* TELNET为了适应许多计算机和操作系统的差异，TELNET定义了数据和命令怎么样通过互联网。这些定义就是所谓的**网络虚拟终端NVT**。\n" +
            "\n" +
            "## <span id=\"www\">万维网WWW</span>\n" +
            ">万维网WWW（World Wide Web）并非某种特殊的计算机网络。**万维网是一个大规模的、联机式的信息储藏所**，英文简称为web。\n" +
            "\n" +
            "* 万维网是一个分布式的超媒体系统，它是超文本系统的扩充。\n" +
            "* 万维网以CS（客户服务器）方式工作。**客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档**。\n" +
            "  - 万维网需要解决的问题：\n" +
            "    1. 怎样标志分布在整个互联网上的万维网文档？\n" +
            "    2. 用什么样的协议来实现万维网上的各种链？\n" +
            "    3. 怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示出来，同时使用户清楚的知道在什么地方存在着链接？\n" +
            "    4. 怎样使用户能够很方便的找到所需要的信息？\n" +
            "  - 解决办法：\n" +
            "    1. 万维网使用**统一资源定位符URL**来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符URL。\n" +
            "    2. 使用**超文本传输协议HTTP**(默认端口80)\n" +
            "    3. 使用**超文本标记语言HTML**来统一差异化。\n" +
            "    4. 使用搜索工具来来方便的查找所需的信息。\n" +
            "* 统一资源定位符URL（Uniform Resource Locator)\n" +
            "  >统一资源定位符URL是用来表示从互联网上得到的资源位置和访问这些资源的方法。\n" +
            "\n" +
            "  - URL的一般形式：\n" +
            "  `<协议>://<主机>:<端口>/<路径>`\n" +
            "  - 使用HTTP的URL\n" +
            "  `<http>://<主机>:<端口>/<路径>`\n" +
            "* 超文本传输协议HTTP（HyperText Transfer Protocol)\n" +
            "  >HTTP协议定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传给浏览器。\n" +
            "\n" +
            "  - HTTP协议规定：\n" +
            "  HTTP规定在HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII码串构成的请求和一个类似通用的互联网扩充，即“类MIME（MIME-like）”的响应组成。\n" +
            "  - HTTP的特点：\n" +
            "    + HTTP是**面向事务的**\n" +
            "\n" +
            "    + HTTP协议**本身是无连接的**\n" +
            "    虽然HTTP使用了TCP连接，但通信双方在交换HTTP报文之前不需要先建立HTTP连接。\n" +
            "    + HTTP协议是**无状态的**\n" +
            "    同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时相同。\n" +
            "  - HTTP协议请求一个万维网文档所需要的时间\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191226172057395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  - HTTP协议目前有两种：\n" +
            "    1. HTTP/1.0\n" +
            "    2. HTTP/2.0\n" +
            "    1997年前普遍使用的是RFC 1945定义的HTTP/1.0，现在普遍使用的是升级版HTTP/1.1\n" +
            "  - HTTP/1.0的缺点：\n" +
            "    每请求一个文档就要有两倍RTT开销。每次请求资源过后就释放TCP连接，下次获取资源时再进行连接。\n" +
            "  - HTTP/1.1对HTTP1.0的改进优化\n" +
            "    HTTP/1.1使用持续连接。所谓持续连接就是万维网服务器在发送响应后任然在一段时间内保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。\n" +
            "    HTTP/1.1协议持续连接分为两种方式：\n" +
            "      1. 非流水线方式\n" +
            "      2. 流水线方式\n" +
            "\n" +
            "  - 代理服务器\n" +
            "    >代理服务器是一种网络实体。它又称为**万维网高速缓存**。代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这些个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按照URL的地址再去互联网访问该资源。\n" +
            "\n" +
            "* 万维网文档\n" +
            "  - 超文本标记语言HTML\n" +
            "  超文本标记语言HTML就是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。\n" +
            "  - 动态万维网文档\n" +
            "  动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。\n" +
            "## <span id=\"email\">电子邮件</span>\n" +
            "### 电子邮件概述\n" +
            "* 电子邮件的两个重要标准\n" +
            "  + **简单邮件传送协议**\n" +
            "  + **互联网文本报文格式**\n" +
            "* 电子邮件系统的三个组成要素\n" +
            "  + **用户代理**\n" +
            "    + 用户代理UA就是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户电脑中的一个程序，因此又被称为**电子邮件客户端软件**\n" +
            "    + 用户代理的功能：\n" +
            "      - **撰写**，给用户提供编辑信件的环境\n" +
            "      - **显示**，能方便的在屏幕上显示出来信\n" +
            "      - **处理**，处理包括发送邮件和接收邮件。\n" +
            "      - **通信**，发信人在撰写邮件完毕后，要利用邮件方发送协议发送到用户所使用的邮件服务器。\n" +
            "  + **邮件服务器**\n" +
            "    + 功能：发送和接收邮件，同时向发件人报告邮件传送结果。\n" +
            "    + 邮件服务器使用的两种协议：\n" +
            "      - 一种协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP。\n" +
            "      - 一种协议用于用户代理从邮件服务器读取邮件，如POP3\n" +
            "  + **邮件发送协议（STMP）和邮件读取协议（POP3）**\n" +
            "\n" +
            "### 简单邮件传送协议SMTP\n" +
            "* **SMTP通信的三个阶段**\n" +
            "  + **连接建立**\n" +
            "    - SMTP客户端每隔一段时间对邮件缓存进行扫描，发现有邮件，就使用SMTP的**熟知端口号25**与邮件服务器端的STMP服务建立TCP连接。\n" +
            "  + **邮件发送**\n" +
            "  + **连接释放**\n" +
            "* **SMTP的缺点**\n" +
            "  - 发送邮件不需要经过鉴别\n" +
            "  - 传送非ASCII码的长报文时，传输效率不高\n" +
            "* **ESMTP协议**\n" +
            "  - 为了解决SMTP的两个缺点，新增了客户端鉴别，服务器接收二进制报文。\n" +
            "\n" +
            "### 邮件读取协议POP3和IMAP\n" +
            "* **邮局协议POP**是一个非常简单、但功能有限的邮件读取协议。\n" +
            "* 使用POP3协议只要用户从POP3服务器读取了邮件，POP3服务器就把该邮件删除。**扩充**：允许用户能够事先设置邮件读取就仍然在POP3服务器中存放的时间。\n" +
            "* **IMAP的优点**\n" +
            "  - 用户可以在不同的地方使用不同的计算机\n" +
            "  - 允许收件人只读取邮件中的一部分\n" +
            "* **IMAP的缺点**\n" +
            "  - 如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在IMAP服务器上。\n" +
            "\n" +
            "### 通用互联网邮件扩充MIME\n" +
            "* **MIME概述**\n" +
            "  - MIME的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。\n" +
            "* **内容传送编码**\n" +
            "  - **ASCII码**\n" +
            "    每行不能超过1000个字符。MIME对这种由ASCII构成的邮件主体不进行任何转换\n" +
            "  - **quoted-printable**\n" +
            "    - 这种编码方法适用于所传送的数据中只有少量的非ASCII码，例如汉字。\n" +
            "    - 这种编码方法的要点是对于所有可打印的ASCII码，除特殊字符等号“=”外，都不改变。\n" +
            "    - 等号“=”和不可打印的ASCII码以及非ASCII码的数据的编码方法是：先将没和字节的二进制代码用两个十六进制数字表示，然后再前面加上一个等号“=”。\n" +
            "  - **base64编码**\n" +
            "    - 先将二进制代码划分为一个个24位长的单元，然后把每一个24位单元划分为4个6位组。6位的二进制代码有64种不用的值，从0~63。先按序号排列大写字母，然后小写字母，然后数字，然后‘+’为62，‘/’为63,。\n" +
            "    - 用“==”表示最后一组只有8位，“=”表示最后一组只有16位。\n" +
            "* **内容类型**\n" +
            "  - MIME规定Content-Type说明必须含有两个标识符，即内容**类型**和**子类型**\n" +
            "## <span id=\"dhcp\">动态主机配置协议DHCP</span>\n" +
            "* DHCP提供了一种机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。\n" +
            "* **动态获取IP的流程**：\n" +
            "  + 需要IP地址的主机在启动时就向DHCP服务器广播发送**发现报文**（将目的IP置为`255.255.255.255`，源IP置为`0.0.0.0`,因为并不知道自己的IP）\n" +
            "  + DHCP服务器先在其数据库查找该计算机的配置信息，若找到则返回其配置信息，若没有找到，则从服务器IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文叫**提供报文**。\n" +
            "  + 但是现在并不是在每一个网络上都设置一个DHCP服务器，而是设置一个DHCP**中继代理**，通常是一台路由器，中继代理收到广播的发现报文之后以**单播**的形式和DHCP服务器通信，并等待回复。\n" +
            "* DHCP服务器分配给客户的IP是**临时的**，因此DHCP客户只能在一段时间内使用这个IP，这段时间称为**租用期**。\n" +
            "* DHCP客户使用的端口是**68**，DHCP服务器使用的端口是**67**\n" +
            "## <span id=\"snmp\">简单网络管理协议SNMP</span>\n" +
            "### 网络管理的基本概念\n" +
            "* **网络管理的内容**\n" +
            "  网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些要求，如实时运行性能、服务器质量等。网络管理常简称为网管。\n" +
            "* 构成SNMP的三个部分：\n" +
            "  + **SNMP本身**，定义了管理站和代理之间所交换的分组格式\n" +
            "  + **管理信息结构SMI**，定义了命名对象和定义对象类型的**通用规则**\n" +
            "  + **管理信息库MIB**，MIB在被管理的实体中创建了命名对象，并规定了其规则。\n","# 网络层\n" +
            "## 网络层提供的两种服务\n" +
            "* **虚电路服务**\n" +
            "  + 当两台计算机进行通信时，也应当先建立连接（但在分组交换中是建立一条**虚电路**），以预留双方通信所需的一切网络资源。\n" +
            "  + 双方沿着已经建立的虚电路发送分组，这样分组的首部不需要填写完整的目的主机地址，而只需要填写这条虚电路的编号，因而减少了分组的开销。\n" +
            "\n" +
            "* 数据报服务\n" +
            "  + 网络层向上只提供简单灵活的、无连接的、精良大努力交付的**数据报服务**。\n" +
            "  + 网络在发送时不需要先建立连接，分一个分组独立发送，其前后的分组无关。**网络层不提供服务质量的承诺**。\n" +
            "  + 可靠通信由高层控制（运输层）\n" +
            "  + 采用这种设计思路的**优点**是：网络造价大大降低，运行方式灵活，能够适应多种应用。\n" +
            "\n" +
            "* 两种服务的对比\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225163931415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "## 网际协议IP\n" +
            "* 与IP协议配套的还有三个协议：\n" +
            "  + **地址解析协议ARP**\n" +
            "  + **网际控制报文协议ICMP**\n" +
            "  + **网际组管理协议IGMP**\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225163946792.png)\n" +
            "\n" +
            "### 虚拟互连网络\n" +
            "* 中间设备根据所在层次的划分：\n" +
            "  + 物理层使用的设备叫**转发器**\n" +
            "  + 数据链路层使用的设备叫**网桥**或者**桥接器**\n" +
            "  + 网络层使用的中间设备叫**路由器**\n" +
            "  + 在网络层以上使用的中间设备叫**网关**\n" +
            "* 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络**在网络层看起来好像是一个统一的网络**。\n" +
            "\n" +
            "### 分类的IP地址\n" +
            "* **IP地址及其表示方法**\n" +
            "  + 整个互联网就是一个**单一的、抽象的网络**\n" +
            "  + IP地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的32位（IPv4）标识符。\n" +
            "* **IP地址编址的三个阶段**\n" +
            "  + **分类的IP地址**\n" +
            "  + **子网的划分**\n" +
            "  + **<font color=\"red\">构成超网</font>**\n" +
            "* **分类的IP地址**\n" +
            "  就是将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个为**网络号**，第二个字段是**主机号**，可以记为：\n" +
            "  `IP地址 ::={<网络号>,<主机号>}`\n" +
            "  如下图：\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225170125493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  + A,B,C类地址都是**单播地址**\n" +
            "  + D类地址用于**多播**\n" +
            "  + E类地址保留\n" +
            "* **常用的三种IP地址**\n" +
            "  + **A类地址**\n" +
            "    - A类地址网络号字段占一个字节，第一位固定为0。\n" +
            "    - 网络号全为0代表这是个保留地址，意思是**本网络**。\n" +
            "    - 网络号全1（127）保留作为本地软件**环回测试**本机进程之间的通信之用。\n" +
            "    - 可指派的网络号为126个（即2<sup>7</sup>-2)\n" +
            "    - A类地址主机号字段占三个字节\n" +
            "    - 全0的主机号表示该IP地址是“本主机”所连接到的**单个地址网络**\n" +
            "    - 全1表示**所有的**，全1的主机号字段表示该网络上的所有主机。\n" +
            "    - 可指派的网络号是16777214（即2<sup>24</sup>-2)\n" +
            "  + **B类地址**\n" +
            "    - B类地址网络号字段占2个字节，前两位固定为10.\n" +
            "    - B类地址的128.0.0.0并不指派，所以B类的最小地址为128.1.0.0.\n" +
            "    - 最大网络数为16383（即2<sup>14</sup>-1）。\n" +
            "    - 最大主机数为65534（即2<sup>16</sup>-2),扣除全0和全1的主机号。\n" +
            "  + **C类地址**\n" +
            "    - C类地址的网络号字段占3个字节，前三位固定为110.\n" +
            "    - C类网络192.0.0.0也是不指派的，最小的网络地址是192.0.1.0。\n" +
            "    - 最大网络数为2097151（即2<sup>21</sup>-1)\n" +
            "    - 最大主机数为254（即2<sup>8</sup>-2),扣除全0和全1的主机号。\n" +
            "  + IP地址的指派范围\n" +
            "   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164012364.png)\n" +
            "* **IP地址的特点**\n" +
            "  + 每一个IP地址都由网络号和主机号两部分组成。\n" +
            "  + IP地址是标志一台主机（或路由器）和一条链路的接口。\n" +
            "  + 具有相同网络号的主机的集合是一个网络。\n" +
            "  + 在IP地址中，所有分配到网络号的网络都是**平等**的，所谓平等是指互联网同等对待每一个IP地址。\n" +
            "### IP地址与硬件地址\n" +
            "* 从层次上看**IP地址**和**硬件地址**的区别\n" +
            "  + <font color=\"red\">物理地址是数据链路层和物理层使用的地址</font>\n" +
            "  + <font color=\"red\">IP地址是网络层和以上各层使用的地址，是一种逻辑地址。</font>\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164029878.png)\n" +
            "* **在IP层抽象的互联网上只能看到IP数据报**\n" +
            "  虽然IP数据报会经过路由器的转发，但是在它首部中的源地址和目的地址**始终**不变。\n" +
            "* 虽然在IP数据报首部有源站IP地址，但**路由器只根据目的站的IP地址的网络号进行路由选择**。\n" +
            "* **在局域网的链路层，只能看见MAC帧**。\n" +
            "  路由器在转发MAC帧的时候，在数据链路层会改变MAC帧的首部和尾部，换上不同的目的地址和源地址。\n" +
            "* 尽管连在一起的网络硬件地址体系各不相同，但IP层抽象的互联网却屏蔽了下层这些很复杂的细节。只要在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机和主机或者路由器之间的通信。\n" +
            "\n" +
            "### 地址解析协议ARP\n" +
            "* **<font color=\"red\">ARP的作用：由IP地址解析出MAC地址**</font>\n" +
            "* ARP在主机**APR高速缓存**存放一个从IP地址到硬件地址的映射表，并且还经常动态更新这个表（新增或超时删除）。\n" +
            "* 每台主机都设有一个**ARP高速缓存**，里面有**本局域网**上的各主机和路由器的IP地址到硬件地址的映射表。\n" +
            "* ARP的工作流程：\n" +
            "  + 当主机A要向本局域网上的某台主机B发送IP数据报时，就先查看本地ARP高速缓存中有无B的IP地址，如果有，就在ARP高速缓存中查出B的硬件地址，然后把这个硬件地址和自己的硬件地址写入MAC帧，再发送给B。\n" +
            "  + 当本地ARP高速缓存没有B的IP地址时，就进行以下步骤找到B的硬件地址：\n" +
            "    - ARP进程在本局域网广播一个APR请求分组：“我的IP是`209.0.0.5`，硬件地址是`00-00-C0-15-AD-18`，我想知道IP为`209.0.0.6`的主机的IP地址”\n" +
            "    - 本局域网上所有运行的ARP进程都收到此ARP请求分组。\n" +
            "    - 主机B的IP地址与请求中的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组（单播），同时写入自己的硬件地址。\n" +
            "    - 主机A收到B的ARP响应分组后就在ARP高速缓存中写入B的IP和硬件地址。\n" +
            "* ARP对保存在高速缓存中的每一个映射地址项目都设置**生存时间**，凡超过生存时间的项目就从高速缓存中删除掉。\n" +
            "* **ARP只能解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题**。若想解决不再同一个局域网的地址映射，必须先由路由器转发到同一个局域网再使用ARP进行解析。\n" +
            "\n" +
            "### IP数据报的格式\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122516411882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "* **IP数据报首部的固定部分中的各字段**\n" +
            "  + **版本** 4位，指IP协议的版本。\n" +
            "  + **首部长度** 4位，最大为15。首部最长为15*32位子（4字节）= 60字节。\n" +
            "  + **区分服务** 8位，用来获得更好的服务。\n" +
            "  + **总长度** 16位，指首部和数据之和的长度。\n" +
            "  + **标识** 16位，IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加一，然后被赋值给标识字段。\n" +
            "  + **标志** 3位，目前只有前两位有意义。\n" +
            "    - 最低位为**MF**，MF=1表示后面还有分片，MF=0表示这是最后一个分片。\n" +
            "    - 中间一位为**DF**，DF=1时表示不能分片，DF=0表示可以分片。\n" +
            "  + **片偏移** 13位，片偏移指出：较长的分组在分片后，谋篇在原分组中的相对位置。\n" +
            "  + **生存时间** 8位，生存时间字段是**TTL**，表示在网络中的寿命（跳数）。每进过一个路由器跳数就减一，如果TTL小于0还没有到达目的主机，就丢弃。\n" +
            "  + **协议** 8位，指出数据报携带的数据时使用何种协议。\n" +
            "  + **首部校验和** 16位，只检验数据报的首部，但不包括数据部分。\n" +
            "  + **源地址** 32位。\n" +
            "  + **目的地址** 32位。\n" +
            "\n" +
            "### IP层转发分组的流程\n" +
            "* **分组转发算法**\n" +
            "  1. 从数据报的首部提取目的主机的IP地址D，得出目的网络地址为N。\n" +
            "  2. 若N就是与此路由器直接相连的某个网络地址，则进行**直接交付**，不需要再经过其他的路由器，直接把数据交付目的主机；否则就是间接交付，执行3。\n" +
            "  3. 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一条路由器；否则，执行4。\n" +
            "  4. 若路由器表中有达到网络N的路由，则把数据传送给路由表中所指明的下一跳路由器；否则，执行5。\n" +
            "  5. 若路由器表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。\n" +
            "  6. 报告转发分组出错。\n" +
            "\n" +
            "## 划分子网和构造超网\n" +
            "\n" +
            "### 划分子网\n" +
            "* **两级IP地址的缺点**\n" +
            "  + IP地址的空间利用率很低\n" +
            "  + 给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。\n" +
            "  + 两级IP地址不够灵活\n" +
            "* **解决两级IP地址的问题**\n" +
            "  + 从两级IP地址到三级IP地址\n" +
            "  + 在两级IP地址中增加一个**子网号**字段\n" +
            "  + 这种做法叫做**划分子网**或者**子网寻址**或**子网路由选择**。\n" +
            "* **划分子网的基本思路**\n" +
            "  + 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个**子网**。划分子网纯属一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。\n" +
            "  + 划分子网的方法是从网络的主机号借用若干位作为子网号，主机位就相应的减少若干位。所以两级IP地址也就变为了三级IP地址：\n" +
            "    `IP地址 ::= {<网络号>,<子网号>,<主机号>}`\n" +
            "  + 凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络好找到链接在本单位网络上的路由器。但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把数据报交付目的主机。\n" +
            "\n" +
            "* **子网掩码**\n" +
            "  * 组成：由连续的1和连续的组成\n" +
            "  + 作用：根据IP地址得出子网的网络地址。（判断一个IP地址是属于哪一个子网的）\n" +
            "  + 方法：将IP地址与子网掩码进行“**与**”运算（按位与），就能得到该IP的属于的子网的网络地址。\n" +
            "   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164159502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "* **默认子网掩码**\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164138444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "### 使用子网时的分组转发\n" +
            "* 使用子网划分后，路右边必须包含三项内容：**目的网络地址**、**子网掩码**和**下一条地址**。\n" +
            "* 分组转发算法如下：\n" +
            "  1. 从收到的数据报首部提取目的IP地址D\n" +
            "  2. 先判断是否为直接交付。对路由器直接相连的网络逐个检查：用各网络的子网掩码和D逐位“与”，看结果是否和相应的网络地址匹配。若匹配，则把分组直接交付，否则就间接交付，执行3。\n" +
            "  3. 若路由表中有目的地址为D的特定主机路由，则把数据传送给路由表中所指明的下一条路由器；否则执行4。\n" +
            "  4. 对路由表每一行，用其中的子网掩码和D逐位“与”，其结果为N，若N与该行的目的网络地址匹配，则把数据报传送给该行指明的下一条路由器，否则执行5.\n" +
            "  5. 若路右边中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器，否则执行6.\n" +
            "  6. 报告转发分组出错。\n" +
            "\n" +
            "### 无分类编址CIDR（构造超网）\n" +
            "* **CIDR**的特点\n" +
            "  + CIDR消除了传统的A类、B类、C类地址以及其划分子网的概念。CIDR把32位的IP地址分为前后两个部分，前面部分是**网络前缀**，用来指明网络，后面部分用来指明主机。CIDR的记法是：\n" +
            "    `IP地址 ::= {<网络前缀>,<主机号>}`\n" +
            "    - CIDR还是用斜线记法，即在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数（如128.14.35.7/20)\n" +
            "  + CIDR把**网络前缀**都相同的连续的IP地址组成一个“CIDR地址快”。\n" +
            "\n" +
            "* **地址掩码**\n" +
            "  + 为了更方便的进行路由选择，CIDR使用32位的**地址掩码**。地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。**在斜线记法中，斜线后面的数字就是地址掩码中1的个数**。\n" +
            "\n" +
            "* **路由聚合（构成超网）**\n" +
            "  + 由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址快来查找目的网络，这种地址的聚合常称为**路由聚合**，也叫**构成超网**。\n" +
            "\n" +
            "* **最长前缀匹配**\n" +
            "  + 在用CIDR时，由于采用了网络前缀这种记法，因此在路由表中的项目也应该有响应的改变，这时候每个项目由**网络前缀**和**下一条地址**组成。但是在查找路由表的时候可能会出现**可能会的不到不止一个匹配的结果**。\n" +
            "  + 出现上述情况**应当从匹配结果中选择具有最长网络前缀的路由**。，这叫**最长前缀匹配**。\n" +
            "  + 例子：\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164218493.png)\n" +
            "\n" +
            "## 网际控制报文协议ICMP\n" +
            "* 作用：为了更有效地转发IP数据报和提高交付的机会，在网际层使用了**网际控制报文协议ICMP**。\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191225164234765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "### ICMP报文的种类\n" +
            "* 种类分两种\n" +
            "  + **ICMP差错报告报文**和**ICMP询问报文**\n" +
            "\n" +
            "* **差错报告报文**\n" +
            "  + **终点不可达** 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。\n" +
            "  + **时间超过** 当路由器收到生存时间为0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。\n" +
            "  + **参数问题** 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点到发送参数问题报文。\n" +
            "  + **改变路由（重定向）** 路由器吧改变路由报文发送给主机，让主机知道下次应该将数据报发送给另外的路由器。\n" +
            "\n" +
            "* **询问报文**\n" +
            "  + **回送请求和回答** ICMP回送请求报文时由主机或路由器向一个特定的目的主机发出的询问。收到报文的主机必须给远主机或路由器发送ICMP回答报文，这种报文用来探测目的站是否可达以及了解其有关状态。\n" +
            "  + **时间戳请求和回答** 时间戳请求回与回答可用于时钟同步和时间测量。\n" +
            "\n" +
            "### ICMP的应用举例\n" +
            "* **PING**\n" +
            "  + 分组网间探测**PING**，用来探测两态主机间的连通性。\n" +
            "  + 直接使用ICMP，没有使用TCP和UDP\n" +
            "* **traceroute**\n" +
            "  + 用来跟踪一个分组从源点到终点的路径。\n" +
            "\n" +
            "## 互联网的路由选择协议\n" +
            "\n" +
            "### 有关路由选择协议的几个基本概念\n" +
            "* **理想的路由算法**\n" +
            "  + 算法必须是正确的和完整的。\n" +
            "  + 算法在计算上应简单\n" +
            "  + 算法能适应通信量个网络拓扑的变化\n" +
            "  + 算法应具有稳定性\n" +
            "  + 算法应是公平的\n" +
            "  + 算法应是最佳的\n" +
            "* **分层次的路由选择协议**\n" +
            "  + 互联网采用的路由选择协议主要是自适应的（动态的）、分布式路由选择协议。\n" +
            "  + 采用分层路由协议的原因：\n" +
            "    - 互联网的规模非常大\n" +
            "    - 许多单位不愿意外界了解到自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网。\n" +
            "\n" +
            "  + **自治系统AS**是在单一技术管理下的一组路由器。\n" +
            "  + 互联网把路由协议分为两大类：\n" +
            "    - **内部网关协议IGP** 即在一个自治系统内部使用的路由选择协议，而这在与互联网中的其他的自治系统选用什么路由协议无关。\n" +
            "    - **外部网关协议EGP** 若源主机和目的主机处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中，这样的协议就是外部网关协议EGP。\n" +
            "  + 自治系统之间的路由选择也叫**域间路由选择**\n" +
            "  + 自治系统内部的路由选择叫做**域内路由选择**\n" +
            "\n" +
            "### 内部网关协议RIP\n" +
            "* RIP是一种分布式的**基于距离向量的路由选择协议**。\n" +
            "* RIP要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。\n" +
            "* RIP允许一条路径最多只能包含15个路由器，当“距离”等于16时即表示不可达。**RIP只适用于小型互联网**\n" +
            "* RIP选择一条具有最少路由器的路由（即最短路由），哪怕还存在一条高速（低时延）但路由器较多的路由。\n" +
            "* **RIP的特点**\n" +
            "  + 仅和相邻路由器交换信息。\n" +
            "  + 路由器交换的信息是**当前本路由器所知道的全部信息，即自己现在的路由表**\n" +
            "  + 按固定的时间间隔交换路由信息\n" +
            "* **距离向量算法**\n" +
            "  对**每一个相邻路由器**发来的RIP报文：\n" +
            "  1. 对地址为X的相邻路由器发来的RIP报文，先修改此报文中的**所有项目**，把“下一跳”字段中的地址都改为X，并把所有的距离都加1，每一个项目都有三个关键数据：**到目的网络N**，**距离是d**，**下一跳路由器是X**。\n" +
            "  2. 对修改后的RIP报文中的每一个项目，执行以下步骤：\n" +
            "  若原来的路由表中没有目的网络N，则把该项目添加到路由表中\n" +
            "  否则（即在路由表中有目的网络N,这时就查看下一跳路由器地址）\n" +
            "     + 若下一跳路由器地址是X，则把收到的项目替换原路由表中的项目\n" +
            "     + 否则（即这个项目是：到目的网络N，但下一跳路由器不是X）\n" +
            "        - 若收到项目中的距离d小于路由表中的距离，则进行更新\n" +
            "        - 否则什么也不做\n" +
            "  3. 若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离设为16.\n" +
            "* RIP存在的一个问题是**当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器**。\n" +
            "* RIP使用运输层的用户数据报UDP进行传送。\n" +
            "\n" +
            "### 内部网关协议OSPF\n" +
            "* 开放最短路径优先OSPF使用分布式的**链路状态协议**\n" +
            "* **OSPF的特点**\n" +
            "  + 向本自治系统中的**所有路由器**发送消息。这里使用**洪泛法**，路由器通过所有输出端口向所有相邻的路由器发送信息，而每一个相邻路由器又再将此信息发往其他所有相邻的路由器。\n" +
            "  + 发送的信息就是本路由器**相邻的所有路由器的链路状态**，但这只是路由器所知道的部分信息。\n" +
            "  + 只有当链路状态**发生变化时**，路由器才向所有路由器使用洪泛法发送此信息。\n" +
            "* OSPF协议可以使所有的路由器都建立一个**链路状态数据库**，这个数据可实际上就是**全网的拓扑结构图**。\n" +
            "* OSPF不使用UDP而是**直接用IP数据报传送**。\n" +
            "\n" +
            "### 外部网关协议BGP\n" +
            "  BGP-4是不同AS的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络（可达）且比较好的路由（不兜圈子），而并非要寻找一条最佳路由。\n" +
            "\n" +
            "### 路由器的构成\n" +
            "* 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。\n" +
            "* 路由器结构可分为两大部分：\n" +
            "  + **路由选择**\n" +
            "  + **分组转发**\n" +
            "\n" +
            "* **分组转发**\n" +
            "  + 交换结构\n" +
            "  + 输入端口\n" +
            "  + 输出端口\n" +
            "\n" +
            "## IPv6\n" +
            "### IPv6的基本首部\n" +
            "* **IPv6所引进的主要变化**\n" +
            "  + **更大的地址空间** 地址空间从2<sup>32</sup>到2<sup>128</sup>\n" +
            "  + **扩展的地址层次结构**\n" +
            "  + **灵活的首部格式**\n" +
            "  + **改进的选项**\n" +
            "  + **允许协议继续扩充**\n" +
            "  + 支持即插即用\n" +
            "  + **支持资源的预分配**\n" +
            "  + **首部改为8字节对齐**\n" +
            "* IPv6数据报由两大部分组成，即**基本首部**和后面的**有效载荷**。\n" +
            "### IPv6地址\n" +
            "* IPv6的目的地址\n" +
            "  + **单播**\n" +
            "  + **多播**\n" +
            "  + **任播**  终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。\n" +
            "\n" +
            "* IPv6使用**冒号十六进制记法**\n" +
            "  + 把每个16位的值用16进制值表示，各值之间用冒号分隔。如`68E6:8C64:FFFF:FFFF:0:1180:9601:FFF`。\n" +
            "  + 允许使用**零压缩**，记一串连续的0可以为一对冒号所取代。如`FF05:0:0:0:0:0:0:B3`可压缩为`FF05::B3`。\n" +
            "  + 规定在任一地址上只能使用一次零压缩。\n" +
            "\n" +
            "### 从IPv4到IPv6过渡\n" +
            "* 向IPv6过渡只能**采用逐步演进的办法**，同时还必须使新装的IPv6系统能够**向后兼容**。\n","# 数据链路层\n" +
            "* 数据链路层适应的信道主要有以下两种类型：\n" +
            "  * **点对点通信**\n" +
            "  * **广播通信**\n" +
            "## 使用点对点信道的数据链路层\n" +
            "\n" +
            "### 数据链路和帧\n" +
            "* 所谓**链路**就是从一个节点**到相邻节点**的一段物理线路（有限或无线），而中间没有任何其他的交换节点。\n" +
            "* 当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了**数据链路**。\n" +
            "* 数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。\n" +
            "### 三个基本问题\n" +
            "* **封装成帧**\n" +
            "  + 封装成帧就是在一段数据的前后分别添加首部和尾部没这样就构成了一个帧。\n" +
            "  + 所有在互联网上传送的数据都以分组（即IP数据报）为传送单位。网络层的IP数据报传送到数据链路层就成为了帧的数据部分。\n" +
            "  + 在帧的数据部分的全面和后面分别添加上首部和尾部，就构成了一个完整的帧。首部和尾部的一个作用就是**帧定界**。\n" +
            "  + 每一种链路层协议都规定了所能传送的帧的数据部分长度上线——**最大传送单元MTU**\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191156362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  + 控制字符**SOH**放在一帧的最前面，**EOT**放在一帧的最后面，最为**帧定界符**。\n" +
            "\n" +
            "* **透明传输**\n" +
            "  + 透明传输就是不管从键盘上输入什么字符都可以放在这样的帧中传输过去。**透明**表示**某一个实际存在的事物看起来却好像不存在一样**。在数据链路层透明的传送数据表示无论什么样的比特组合的数据，都能够按照原样没有差错地通过这个数据链路层。\n" +
            "  + 传输可能遇到的问题：\n" +
            "    - 当数据部分出现和帧定界符一样的字符时，数据链路层会错误的找到帧的边界，把部分帧收下，而把剩下的数据丢弃。这种传输就是**不透明的**。\n" +
            "  + 解决透明传输的问题：\n" +
            "    - **字节填充（字符填充）**\n" +
            "      发送端的数据链路层在数据中出现控制字符==SOH==或==EOT==的前面插入一个**转义字符**==ESC==。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。如果转义字符==ESC==也出现在数据中，那就在转义字符前面再插入一个转义字符。\n" +
            "\n" +
            "* **差错检测**\n" +
            "  + **比特差错**\n" +
            "  比特在传输过程中产生1变为0,0变为1的差错情况\n" +
            "  + **误码率BER**\n" +
            "  传输错误的比特占所传输比特总数的比特率。\n" +
            "  + **循环冗余检验CRC**\n" +
            "    - **原理**：假设传输数据M为k位，CRC就在数据后面添加供差错检测用的n位**冗余码**，然后构成一个帧发送出去，一共发送（k+n）位。\n" +
            "    - **n位冗余码的产生**：在M的后面添加n个0，得到的（k+n）位的数**除以**收发双方事先商定的长度为（n+1）的除数P（可知n大小是协商得出），得出商是Q而余数是R（n位），这个余数就作为冗余码拼接在数据M的后面发送出去。这种为了进行检错而添加的冗余码常称为**帧检验序列FCS**。\n" +
            "    - **通过CRC检验数据正确性**：在接收端把接收到的数据以帧为单位进行CRC检验，把收到的每一个帧都除以同样的除数P（模2运算，和异或运算类似），然后检查余数R。如果余数为0，则表示无差错，如果不等于0，则有差错。\n" +
            "    - 运算的例子：\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191224541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "## 点对点协议PPP\n" +
            "### PPP协议的特点\n" +
            "* PPP协议是用户计算机和ISP进行通信时使用的数据链路层协议。\n" +
            "* **PPP协议应满足的需求**\n" +
            "  + 简单\n" +
            "  + 封装成帧\n" +
            "  + 透明性\n" +
            "  + 多种网络层协议\n" +
            "  + 多种类型链路\n" +
            "  + 差错检验\n" +
            "  + 检测连接状态\n" +
            "  + 最大传送单元\n" +
            "  + 网络层地址协商\n" +
            "  + 数据压缩协商\n" +
            "* **PPP协议的组成**\n" +
            "  + 一个将IP数据报封装到串行链路的方法。\n" +
            "  + 一个用来尽力、配置和测试数据链路连接的**链路控制协议**。\n" +
            "  + 一套**网络控制协议NCP**。\n" +
            "\n" +
            "### PPP协议的帧格式\n" +
            "* **各字段的意义**\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191246477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "* **字节填充**\n" +
            "  + **在异步传输时**，把转义字符定义为`0x7D`,并使用字节填充\n" +
            "  + 把信息字段中出现的每一个`0x7E`字节转变为2字节序列（`0x7D`,`0x5E`)\n" +
            "  + 若信息字段中出现一个`0x7D`的字节，则把`0x7D`转变为2字节序列（`0x7D`,`0x5D`)\n" +
            "  + 若信息中出现了ASCII码的控制字符（数值小于`0x20`），则在该字符前面要加入一个`0x7D`字节，同时改变该字符的编码。\n" +
            "* **零比特填充**\n" +
            "  + PPP协议在使用SONET/SDH链路时，使用**同步传输**，并使用领比特填充方法来实现透明传输。\n" +
            "  + 再发送端，先扫描整个信息字段，只要发现有五个连续的1，就立即填入一个0。\n" +
            "\n" +
            "### PPP协议的工作状态\n" +
            "\n" +
            "## 使用广播信道的数据链路层\n" +
            "### 局域网的数据链路层\n" +
            "* 局域网的最主要特点是：**网络为一个单位所拥有，且地理范围和站点数目均有限**\n" +
            "* 局域网的主要优点：\n" +
            "  + 具有广播功能，从一个站点可以很方便的访问全网。\n" +
            "  + 便于系统的扩展个逐渐演变，各设备的位置可灵活调整和改变。\n" +
            "  + 提高了系统的可靠性、可用性、和生存性。\n" +
            "* 局域可按网络拓扑进行分类：**星型网（a）**、**环形网（b）**、**总线网（c）**。\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191309874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "* 共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便地共享通信媒体资源。在技术上有两种方法：\n" +
            "  + **静态划分信道** 如PDM，TDM，WDM，CDM等等\n" +
            "  + **动态媒体接入控制** 又称为**多点接入**，特点是信道并非在用户通信时固定分配给用户。这里又分为两类\n" +
            "    - **随机接入**  所有用户可随机地发送信息。\n" +
            "    - **受控接入**  用户不能随机地发送信息而必须服从一定的控制。\n" +
            "\n" +
            "* 适配器的作用\n" +
            "  + 进行数据的串并转换\n" +
            "  + 进行对数据帧的差错处理，帧错误就直接丢弃，正确就通知CPU\n" +
            "  + 存储计算机的硬件地址\n" +
            "### CSMA/CD协议（载波监听多点接入/碰撞检测协议）\n" +
            "* **总线的特点**：当一台计算机发送数据时，总线上的所有计算机都能够检测到这个数据。总线上只要有一台计算机在发送数据，总线的传输资源就被占用，所以**在同一时间只能允许一台计算机发送数据**。\n" +
            "\n" +
            "* 为了通信的简便，以太网采取了以下两种措施：\n" +
            "  + 采用较为灵活的**无连接**的工作方式，不必建立连接就可以直接发送数据。\n" +
            "    - 适配器对发送的数据帧不进行编号，也不要求对方发回确认\n" +
            "    - 提供的是不可靠的交付\n" +
            "    - 对有差错的帧是否重传由高层来决定\n" +
            "    - 采用**载波监听多点接入/碰撞检测CSMA/CD协议**\n" +
            "  + 以太网发送的数据都使用**曼彻斯特编码**的信号。\n" +
            "* CSMA/CD协议的要点\n" +
            "  + **多点接入** 说明这是总线型网络\n" +
            "  + **载波监听** 就是用电子技术检测总线上有没有其他计算机也在发送。\n" +
            "  + **碰撞检测** 也就是变发送变监听，即适配器变发送数据边检测信上的信号电压的变化情况，以便判断自己再发送数据时其他站是否也在发送数据。\n" +
            "* CSMA/CD的参数定义\n" +
            "  + 在局域网的分析中，常把总线上的**单程端到端传播时延**记做==$\\tau$==\n" +
            "  + 每一个站在自己发送数据之后的一小段时间之内，存在着遭遇碰撞的可能性，这一小段时间是不确定的，因此以太网不曹正某一时间之内一定能够把自己的数据帧成功地发送出去。\n" +
            "  + 以太网端到端的往返时间2$\\tau$称为**争用期**或**碰撞窗口**。发送的数据经过争用期还没有检测到碰撞，才能肯定这次发送不会碰撞。\n" +
            "  + 以太网使用**截断二进制指数退避**算法来确定碰撞重传的时机。\n" +
            "    - 算法让发生碰撞的站停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是**推迟**一个随机的时间。\n" +
            "    - 协议规定了基本退避时间为争用期2$\\tau$,具体的争用期时间是51.2us。退避的时间为一个随机数乘以基本退避时间。\n" +
            "  + 以太网规定最短帧长为**64字节**。凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。\n" +
            "  + **强化碰撞** 当发送数据的站一旦发现了碰撞时，除了立即发送数据外，还要在继续发送32bit或者48bit的**人为干扰信号**，以便让所有的用户都知道现在已经发生了碰撞。\n" +
            "  + 以太网规定**帧间最小间隔**为9.6us，相当于96比特时间\n" +
            "* CSMA/CD协议工作的流程\n" +
            "  1. 准备发送：适配器重网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器缓存中。在发送前，必须先**检测信道**\n" +
            "  2. 检测信道：若检测到信道忙，则应不听地检测，一直等待信道转变为空闲。若检测到信道空闲，并在96比特时间内信道保持空闲，就发送这个帧。\n" +
            "  3. 再发送过程中仍不停地检测信道，即网络适配器要变发送变监听。这里有两种可能性\n" +
            "      + 发送成功：在争用期一直未检测到碰撞。这个帧发送成功。\n" +
            "      + 发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着执行指数退避算法，等待r倍512比特时间后，返回到步骤2，继续检测信道，若重传16次仍不能成功，则停止重传而向上报错。\n" +
            "\n" +
            "### 使用集线器的星型拓扑\n" +
            "* 传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。这种以太网采用星型拓扑，在星型中央增加了一种可靠性非常高的设备，叫做**集线器**。\n" +
            "* 1990年IEEE制定出星型以太网`10BASE-T`的标准`802.3i`。10代表10 Mbits/s的数据率，BASE表示连接线上的信号是基带信号，T代表是双绞线。\n" +
            "* **集线器的特点**\n" +
            "  + 使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA/CD协议。网络中的各站需竞争对传输媒体的控制，并且**在同一时刻之多只允许一个站发送数据**。\n" +
            "  + 一个集线器有许多**接口**，一个集线器很像一个**多接口的转发器**。\n" +
            "  + **集线器工作在物理层**，它的每个接口仅仅简单的转发比特，收到什么就转发什么。\n" +
            "  + 集线器采用了专门的芯片，进行自适应串音回波抵消。\n" +
            "\n" +
            "### 以太网的信道利用率\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191342730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "* 要提高以太网信道的利用率，就必须减小$\\tau$与$T_0$之比，在以太网中定义了参数$a$,它是以太网单程端到端时延$\\tau$与帧的发送时延$T_0$之比：\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122419135920.png)\n" +
            "\n" +
            "### 以太网的MAC层\n" +
            "* **MAC层的硬件地址**\n" +
            "  + 在局域我那个中，**硬件地址**又称为**物理地址**或**MAC地址**\n" +
            "  + 现在局域网适配器实际上使用的都属**6字节**的MAC地址。\n" +
            "* **MAC地址的组成**\n" +
            "  + 前3个字节称为**组织唯一标识符OUI**，通常也称为**公司标识符**。由厂家向向IEEE购买\n" +
            "  + 后3个字节则称为**扩展标识符**。由厂家自己指派。\n" +
            "  + IEEE规定第一字节的最低位为I/G位，为0时，地址字段表示一个**单个站地址**，为1时，表示**组地址**，用来进行**多播**。\n" +
            "* **适配器的过滤功能**\n" +
            "  + 适配器从网络上每收到一个MAC帧就先用硬件检查MAC帧中的目的地址，如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他处理。发往本站的帧包括：\n" +
            "    - **单播**帧（一对一），即收到的帧的MAC地址与本站的硬件地址相同。\n" +
            "    - **广播**帧（一对全体），即发送给本局域网上所有站点的帧。\n" +
            "    - **多播**帧（一对多），即发送给本局域网上一部分站点的帧。\n" +
            "* **MAC帧的格式**\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122419141956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "## 扩展的以太网\n" +
            "\n" +
            "### 在物理层扩展以太网\n" +
            "* 扩展主机和集线器之间的距离采用一种简单的方式就是使用**光纤**和一对光纤调制解调器。\n" +
            "* 使用多个集线器，就可以连接成覆盖更大范围的多级星型结构的以太网。\n" +
            "\n" +
            "### 在数据链路层扩展以太网\n" +
            "* **网桥** 对收到的帧根据其MAC帧的目的地址进行转发和过滤。\n" +
            "* 使用**交换式集线器**替换了网桥。交换式集线器常被称为以太网**交换机**或**第二层交换机**，强调这种交换机**工作在数据链路层**。\n" +
            "* **以太网交换机的特点**\n" +
            "  + 以太网交换机就是一个多接口网桥，一般都工作在全双工方式。\n" +
            "  + 具有并行性，能同时联通多对接口，使多对主机能同时通信。\n" +
            "  + 接口含有存储器，能在繁忙的时候存储到来的帧。\n" +
            "  + 即插即用，内部采用**帧交换表**，通过**自学习**算法主键简历起来。\n" +
            "  + 若对于10Mbit/s的以太网，才有10个接口的交换机则每个接口的带宽都是10Mbit/s，总的带宽为100Mbit/s，连接在交换机的每个用户的带宽都是10Mbit/s。\n" +
            "* **以太网交换机的自学习功能**\n" +
            "  + 自学习的流程\n" +
            "    - 当交换表为空时，此时接收到一个帧，查找交换表，如果没有查到应从哪个接口转发这个帧，就先把当前这个帧对应的主机信息和接口写入表中，然后广播给所有主机。\n" +
            "    - 当查找交换表中含有当前接收帧的目的地址应转发的接口时，就添加当前帧对应主机和接口信息到交换表，然后向查找到的接口广播消息。\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191224191437337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  + **生成树协议**\n" +
            "    解决交换机自学习过程中的都圈子的现象。要点是不改变网络的时机拓扑，但在逻辑上切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树桩结构。\n" +
            "\n" +
            "### 虚拟局域网\n" +
            "## 高速以太网\n" +
            "* 100BASE-T以太网\n" +
            "* 吉比特以太网\n" +
            "* 10吉比特以太网\n" +
            "* 使用以太网进行宽带接入\n","# 虚拟机优化\n" +
            "## 早期（编译期）优化\n" +
            "### 概述\n" +
            "  Java语言的“编译期”其实是一段“不确定”的操作过程，因为可能出现如下的几种情况\n" +
            "  * 可能是指一个前端编译器（其实叫“编译器的前端”更准确）把`*.java`文件转变成`.class`文件的过程。代表编译器：**Javac**,**ECJ**。\n" +
            "  * 可能是指虚拟机的后端运行期编译期（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。代表编译器：HotSpot VM的**C1、C2**编译器。\n" +
            "  * 可能是使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把`*.java`文本编译成本地机器代码的过程。代表编译器：**GNU Compiler for the Java(GCJ)**、**Excelsior JET**。\n" +
            "\n" +
            "### Javac编译器\n" +
            "* **Javac的源码与调试**\n" +
            "  Java虚拟机规范（第二版）并没有对如何把Java源码文件转变为Class文件的编译过程进行十分严格的定义，这导致Class文件编译在某种程度上与具体JDK实现相关。\n" +
            "\n" +
            "  从Javac的代码来看，编译过程大概科宇分为三个过程：\n" +
            "    + **解析与填充符号表过程**\n" +
            "    + **插入式注解处理器的注解处理过程**\n" +
            "    + **分析与字节码生成的过程**\n" +
            "  编译过程如图：\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223162001323.png)\n" +
            "* **解析与符号填充符号表**\n" +
            "  解析步骤包括了经典程序编译原理中的词法分析和语法分析。\n" +
            "  + **词法、语法分析**\n" +
            "    - 词法分析是将源代码的字符流转变为**标记**集合，单个字符是程序编写的最小元素，而标记则是编译过程的最小元素。\n" +
            "    - 语法分析是根据Token序列构造抽象语法树的过程。抽象语法树（Abstract Syntax Tree，ASL）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构。\n" +
            "  + **填充符号表**\n" +
            "    - 符号表是由一组符号地址和符号信息构成的表格。\n" +
            "* **注解处理器**\n" +
            "  + 在JDK1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。\n" +
            "  + 如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及符号填充表的过程重新处理，知道所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个**Round**。\n" +
            "\n" +
            "* 语义分析与字节码生成\n" +
            "  + 抽象语法树能够表示一个结构正确的源程序的抽象，但无法保证源程序是抽象的。而**语义分析**的主要任务是对结构上正确的源程序进行上下文有关性质的检查。\n" +
            "  + 语义分析过程分为**标注检查**和**数据及控制流分析**两部分\n" +
            "  + **标注检查**\n" +
            "    标注检查步骤的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。\n" +
            "  + **数据及控制流分析**\n" +
            "    数据及控制流分析是对程序上下文逻辑的更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理。\n" +
            "  + **解语法糖**\n" +
            "    - 语法糖也称糖衣语法，指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员的使用。\n" +
            "    - Java中最常见的语法糖主要有**泛型**、**变长参数**、**自动装箱/拆箱**等，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的语法结构，这个过程称为**解语法糖**。\n" +
            "  + **字节码生成**\n" +
            "    - 字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化为字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。\n" +
            "### Java语法糖的味道\n" +
            "* **泛型与类型擦除**\n" +
            "* **自动装箱/拆箱与循环遍历**\n" +
            "* **条件编译**\n" +
            "## 晚期（运行期）优化\n" +
            "### 概述\n" +
            "* 在部分商用虚拟机中，Java程序最初是通过**解释器**进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为“**热点代码**”。\n" +
            "* 为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为**即时编译器（Just In Time Compiler)**\n" +
            "### HotSpot虚拟机内的即时编译器\n" +
            "* 为何HotSpot虚拟机要是用解释器与编译器并存的架构？\n" +
            "* 为何HotSpot虚拟机要实现两个不同的即时编译器？\n" +
            "* 程序何时使用解释器执行？何时使用编译器执行？\n" +
            "* 那些程序代码会被编译为本地代码？如何编译为本地代码？\n" +
            "* 如何从外部观察即时编译器的编译过程和编译原理？\n" +
            "#### 解释器与编译器\n" +
            "* HotSpot同时包含解释器于编译器\n" +
            "* 解释器于编译器两者各有优势：\n" +
            "  + 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。\n" +
            "  + 在程序运行之后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率。\n" +
            "* 编译器和解释器经常配合工作\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223162304283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "* HotSpot虚拟机中内置了两个即时编译器，分别称为**Client Compiler**和**Server Compiler**，简称为**C1**和**C2**。\n" +
            "* 主流的HotSpot虚拟机默认采用解释器与其中一个编译器直接配合的方式工作，程序采用哪一个编译器，取决于虚拟机的运行模式。\n" +
            "* 为了在启动程序响应速度与与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐采用**分层编译**的策略。\n" +
            "  + 第0层，程序解释执行，解释器不开启性能监控功能，可触发第一层编译。\n" +
            "  + 第1层，也称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。\n" +
            "  + 第2层，也称C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。\n" +
            "\n" +
            "#### 编译对象与触发条件\n" +
            "* 再运行过程中会被即时编译器编译的“热点代码”有两类：\n" +
            "  + **被多次条用的方法**\n" +
            "  + **被多次执行的循环体**\n" +
            "* 对于第一种情况，由于是由方法调用触发的编译，因此编译器理所当然的会以整个方法作为编译对象，这种编译也是虚拟机中标准的**JIT编译方式**。\n" +
            "* 对于第二种情况，尽管编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象。这种编译方式因为编译发生在方法执行的过程中，因此也被称为**栈上替换（OSR）**。\n" +
            "* 判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为**热点探测**。\n" +
            "* 目前主要的热点探测的方式有两种：\n" +
            "  + **基于采样的热点探测**\n" +
            "    - 采用这种方法的虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个歌方法就是“**热点方法**”。\n" +
            "    - 优点： 实现简单、高效，还可以简单的获取方法调用关系。\n" +
            "    - 缺点： 很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而打乱热点探测。\n" +
            "  + **基于计数器的热点探测**\n" +
            "    - 采用这种方法的虚拟机会为每个方法（甚至是代码块）简历计数器，统计方法执行的次数，如果方法执行的次数超过一定的阈值就认为它是“**热点方法**”。\n" +
            "    - 优点： 统计结果相对精准\n" +
            "    - 缺点： 实现复杂，不能直接获取到方法的调用关系。\n" +
            "* HotSpot使用的是第二种——**基于计数器的热点探测方法**，因此它为每个方法准备了两类计数器：**方法调用计数器**和**回边计数器**。\n" +
            "  + 方法调用计数器\n" +
            "    用于统计方法被条用的次数，下面给出调用规则\n" +
            "   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223162344730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "    - 如果不做任何设置，执行引擎并不会等待编译请求完成，而是继续进入解释器按照解释的方式执行字节码。\n" +
            "    - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对频率，即一段时间之内方法被调用的次数。\n" +
            "  + 会变计数器\n" +
            "    统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“**回边**”。\n" +
            "    给出调用规则\n" +
            "    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191223162322755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "\n" +
            "### 编译优化技术\n" +
            "#### 优化技术概览\n" +
            "* 具有代表性的几项优化技术：\n" +
            "  + 语言无关的经典优化技术之一：**公共子表达式消除**\n" +
            "  + 语言相关的经典优化技术之一：**数组范围检查消除**\n" +
            "  + 最重要的优化技术之一：**方法内联**\n" +
            "  + 最前沿的优化技术之一：**逃逸分析**\n" +
            "\n" +
            "#### 公共子表达式消除\n" +
            "* 公共子表达式消除是一个普遍应用于各种编译器的经典优化技术，它的含义是：如果一个表达式E已经计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就成为了公共子表达式。\n" +
            "* 对于公共子表达式没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替E就可以了。\n" +
            "* 如果这种优化仅限于程序的基本快内，便称为**局部公共子表达式**。\n" +
            "* 如果这种优化的返回涵盖了多个基本块，那就称为**全局公共子表达式**。\n" +
            "\n" +
            "#### 数组边界检查消除\n" +
            "* 一种情况是数组下标是一个常量，如`foo[3]`，只要在编译期间根据数据流分析来确定`foo.length`的值，并判断下标“3”没有越界，执行的时候就无须判断了。\n" +
            "* 一种情况是数组访问发生在循环中，并且使用循环变量来访问数组，如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0,foo.length)之内，那在整个循环中就可以把数组的上下界检查消除。\n" +
            "\n" +
            "#### 方法内联\n" +
            "* CHA\n" +
            "  - 类型继承关系分析（Class Hierarchy Analysis)\n" +
            "    + 这是一种基于整个应用程序的类型分析技术，它用于确定在目前已加载的类中，某个接口是否有多与一种的实现，某个类是否存在子类、子类是否为抽象类等信息。\n" +
            "    + 目的：为了解决虚方法内联的问题。\n" +
            "* 编译器在进行内联的选择：\n" +
            "  + 如果是非虚方法，则直接进行内联。\n" +
            "  + 如果是虚方法，则会想CHA查询此方法在当前程序下是否有多个目标版本可供选择，如果只有一个版本，则也可以进行内联。不过这种内联属于**激进优化**，需要预留一个“逃生门”，称为**守护内联**。\n" +
            "  + 如果是虚方法，且向CHA查询出来的结果是由多个版本的目标方法可供选择，则编译器还会进行最后一次努力，使用**内联缓存**来完成内联。\n" +
            "\n" +
            "#### 逃逸分析\n" +
            "* 逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义之后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为**方法逃逸**。\n" +
            "* 如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问这个对象，则可能为这个变量进行一些高效的优化。\n" +
            "  + **栈上分配**\n" +
            "    如果确定一个对象不会逃逸到方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁，可以减小垃圾收集器的压力。\n" +
            "  + **同步消除**\n" +
            "    如果逃逸分析可以确定一个变量不会逃逸出线程，无法被其他线程访问，那么对这个变量实施的同步措施就可以消除掉。\n" +
            "  + **标量替换**\n" +
            "    - **标量**是指一个数据已经无法再分解为更小的数据来表示了。如果一个数据可以继续分解，那它就称为**聚合量**。\n" +
            "    - 如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。\n" +
            "* 逃逸分析这项优化并不成熟，原因是：不能保证逃逸分析的性能收益必定高于它的消耗。\n" +
            "## 总结\n" +
            "* 首先介绍了早期（编译期）的优化，介绍了Java源代码编译为字节码的过程。\n" +
            "* 了解到编译的大致过程：\n" +
            "  + 解析与填充符号表过程\n" +
            "  + 插入式注解处理器的注解处理过程\n" +
            "  + 分析与字节码生成过程。\n" +
            "* 然后介绍了晚期（运行期）的优化\n" +
            "  - 介绍了解释器和编译器\n" +
            "  - 介绍了HotSpot的及时编译器C1和C2\n" +
            "  - 了解了及时编译的触发条件\n" +
            "    + 对于方法体的标准JIT\n" +
            "    + 对于方法内循环体的**栈上替换**\n" +
            "    + 热点探测\n" +
            "  - 了解了几种编译期的优化技术\n","## 章节总结\n" +
            "### 第三章   迭代器（iterators）概念与traits编程技法\n" +
            "#### 3.1 迭代器设计思维——STL关键所在\n" +
            ">STL中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一帖胶着剂将他们撮合在一起。迭代器就是算法和容器之间的胶着剂。\n" +
            "#### 3.2 迭代器是一种smart pointer\n" +
            ">迭代器是一种行为类似指针的对象，而指针的各种行为中最常见的也是最重要的便是内容提领和成员访问，因此迭代器最终要的编程工作就是对`operator*`和`operator->`进行重载工作。\n" +
            "#### 3.3 迭代器响应型别（associated types)\n" +
            ">在STL算法中运用迭代器时，很可能会用到**相应型别**。什么是相应型别？迭代器所指之物的型别便是其一。比如`vector<int>nums`中的`int`就是其响应型别。\n" +
            "  * 假设有必要声明一个变量，以“迭代器所指对象的型别”为型别？怎么做\n" +
            "    - 利用模板参数。比如：\n" +
            "    ```\n" +
            "    template <typename I,typename T>\n" +
            "    void func_impl(I iter,T t){\n" +
            "      T temp;  // 这里就解决了问题\n" +
            "    }\n" +
            "    ```\n" +
            "  * 迭代器响应型别不只是“迭代器所指对象型别”一种，一共有**五种**，并非任何情况下任何一种都可以通过上诉的模板参数的方式实现；\n" +
            "#### 3.4 Traits（特性）编程技法——STL源代码门钥\n" +
            "  * 上述3.3中所说的“迭代器所指对象的型别”称为该迭代器的value_type.\n" +
            "  * 当value_type必须用于函数的返回值，上述3.3做法不能使用。怎么操作？\n" +
            "    - 声明模板内嵌类型\n" +
            "    ```\n" +
            "    template <class T>\n" +
            "    struct MyIter{\n" +
            "      typedef T value_type;\n" +
            "      T * ptr;\n" +
            "      MyIter(T* p = 0):ptr(0){}\n" +
            "      T & operator*()const{return *ptr;}\n" +
            "    };\n" +
            "\n" +
            "    template <class I>\n" +
            "    typename I::value_type\n" +
            "    func(I iter){\n" +
            "    return * iter;\n" +
            "    }\n" +
            "    ```\n" +
            "    **可以完成class type的问题，但是如果不是class type，就没办法定义内嵌类型。但STL绝对必须接受原生指针作为一种迭代器，所以上面的设计还不够**\n" +
            "  * 利用模板的Partial Specialization（偏特化）解决上述基础类型没办法内嵌的问题。此处引入**iterator_traits**。\n" +
            "    - **iterator_traits**\n" +
            "    ```\n" +
            "    template <class I>\n" +
            "    struct iterator_traits{\n" +
            "      typedef typename I::value_type value_type;\n" +
            "    }\n" +
            "    ```\n" +
            "    上述函数`func`变成如下\n" +
            "    ```\n" +
            "    template <class I>\n" +
            "    typename iterator_traits<I>::value_type\n" +
            "    func(I iter){\n" +
            "    return * iter;\n" +
            "    }\n" +
            "    ```\n" +
            "    这比之前多了一层间接性，好处是traits可以拥有特化版本，可以用于解决上述基础类型没办法定义内嵌类型的问题。\n" +
            "  * 利用iterator_traits解决基础类型不能定义内嵌类型的问题：\n" +
            "    - T *\n" +
            "    ```\n" +
            "    template <class T>\n" +
            "    struct iterator_traits<T*>{\n" +
            "      typedef T value_type;\n" +
            "    };\n" +
            "    ```\n" +
            "    - const T *\n" +
            "    ```\n" +
            "    template <class T>\n" +
            "    struct iterator_traits<const T*>{\n" +
            "      typedef T value_type;\n" +
            "    };\n" +
            "    ```\n" +
            "  * 迭代器相应型别有五种\n" +
            "    - **value_type**\n" +
            "    - **difference_type**\n" +
            "    - **pointer**\n" +
            "    - **reference**\n" +
            "    - **iterator_catagory**\n" +
            "    ```\n" +
            "    template <class I>\n" +
            "    struct iterator_traits{\n" +
            "      typedef typename I::iterator_catagory iterator_catagory;\n" +
            "      typedef typename I::value_type value_type;\n" +
            "      typedef typename I::difference_type difference_type;\n" +
            "      typedef typename I::pointer pointer;\n" +
            "      typedef typename I::reference reference;\n" +
            "    }\n" +
            "    ```\n" +
            "  * <font color=\"#f42b7f\">value_type</font>\n" +
            "  >所谓value_type,是指迭代器所指对象的型别。任何一个打算与STL算法有完美搭配的class，都应该定义自己的value_type内嵌型别。\n" +
            "  * <font color=\"#f42b7f\">difference_type</font>\n" +
            "    >difference_type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。\n" +
            "\n" +
            "    ```\n" +
            "    //针对原生指针设计的“偏特化”版本\n" +
            "    template <class I>\n" +
            "    struct iterator_traits<T*>{\n" +
            "      ····\n" +
            "      typedef ptrdiff_t difference_type;  //ptrdiff_t为C++内建类型，在<cstddef>中\n" +
            "    };\n" +
            "    ```\n" +
            "  * <font color=\"#f42b7f\">reference type</font>\n" +
            "  * <font color=\"#f42b7f\">pointer type</font>\n" +
            "    ```\n" +
            "    //针对原生指针设计的“偏特化”版本\n" +
            "    template <class T>\n" +
            "    struct iterator_traits<T*>{\n" +
            "      ····\n" +
            "      typedef T* pointer;\n" +
            "      typedef T& reference;\n" +
            "    };\n" +
            "\n" +
            "    //针对原生的pointer-to-const指针设计的“偏特化”版本\n" +
            "    template <class T>\n" +
            "    struct iterator_traits<const T*>{\n" +
            "      ····\n" +
            "      typedef const T* pointer;\n" +
            "      typedef const T& reference;\n" +
            "    };\n" +
            "    ```\n" +
            "  * <font color=\"#f42b7f\">iterator_catagory(迭代器类别)</font>\n" +
            "    迭代器根据移动特性与施行操作，分为五类：\n" +
            "    - **Input Iterator**:这种迭代器所指对象，不允许外界改变。只读。\n" +
            "    - **Output Iterator**：只写。\n" +
            "    - **Forword Iterator**：允许“写入型”算法( 例如replace（）)在这种迭代器所形成的区间上进行读写操作。\n" +
            "    - **Bidirectional Iterator**:可双向移动。\n" +
            "    - **Random Access Itertor**：最强大，涵盖前面所有迭代器的功能。\n" +
            " ![迭代器的分类与从属关系](https://img-blog.csdnimg.cn/20191128172301380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "  * 设计算法时，针对上图的某种迭代器提供一个明确定义，并针对更强化的的某种迭代器提供另一种，这样才能在不同的情况下**提供最大效率**;\n" +
            "  * 针对上述“<span id=\"max_efficiency\">提供最大效率”</span>提供一个例子：\n" +
            "    ```\n" +
            "    //针对Input Iterator\n" +
            "    template<class InputIterator,class Distance>\n" +
            "    void advance_II(InputIterator & i,Distance n)\n" +
            "    {\n" +
            "      //单向，逐一前进\n" +
            "      while(n--)++i;\n" +
            "    }\n" +
            "\n" +
            "    //针对Bidirectional Iterator\n" +
            "    template<class BidirectionalIterator,class Distance>\n" +
            "    void advance_BI(BidirectionalIterator & i,Distance n)\n" +
            "    {\n" +
            "      //双向，逐一前进\n" +
            "      if(n>=0)\n" +
            "        while(n--)++i;\n" +
            "      else\n" +
            "        while(n++)++i;\n" +
            "    }\n" +
            "\n" +
            "    //针对Random Access Iterator\n" +
            "    template<class BidirectionalIterator,class Distance>\n" +
            "    void advance_RAI(RandomAccessIterator & i,Distance n)\n" +
            "    {\n" +
            "      //双向，跳跃前进\n" +
            "      i += n;\n" +
            "    }\n" +
            "    ```\n" +
            "    现在程序调用advance()时，该选择那一份函数定义？\n" +
            "    - 选择advance_II(),对RandomAccessIterator而言极度缺乏效率，O(1)-->O(n);\n" +
            "    - 选择advance_RAI(),则它无法接受Input Iterator;\n" +
            "    - <span id=\"question_iterator_category\">给出一种解决办法</span>\n" +
            "      ```\n" +
            "      template<class InputIterator,class Distance>\n" +
            "      void advance(InputIterator & i,Distance n)\n" +
            "      {\n" +
            "        if(is_random_access_iterator(i))   //此函数有待设计\n" +
            "          advance_RAI(i,n);\n" +
            "        else if(is_bidrectional_iterator(i))  //此函数有待设计\n" +
            "          advance_BI(i,n);\n" +
            "        else\n" +
            "          advance_II(i,n);\n" +
            "      }\n" +
            "      ```\n" +
            "  * <a href=\"#question_iterator_category\" title=\"给出一种解决办法\">上述解决办法</a>有一个缺陷——这样的执行期才决定使用哪一个版本，会影响程序效率。最好是在编译器就能选择正确的版本。\n" +
            "  * 解决上诉执行期选择损失效率的方法是：**函数重载**\n" +
            "    >前述三个advance_XX()都有两个函数参数，型别都未定（因为都是template参数）。为了令其同名，形成重载函数，我们必须加上一个型别已经确定的函数参数，使函数重载机制得以使用。\n" +
            "    - 设计考虑如下：如果traits有能力萃取出迭代器的种类，我们便可以利用这个“迭代器类型”相应型别作为advanced（）的第三个参数。\n" +
            "      这个相应型别一定必须是一个**class type**，不能只是数值号码类的东西，因为编译器需要依赖它（一个型别）来进行重载决议。\n" +
            "    - 定义五个classes，代表五种迭代器类型：\n" +
            "      ```\n" +
            "      //五个作为标记用的型别（tag types）\n" +
            "      struct input_iterator_tag{};\n" +
            "      struct output_iterator_tag{};\n" +
            "      struct forword_iterator_tag:public input_iterator_tag{};\n" +
            "      struct bidirectional_iterator_tag:public forword_iterator_tag{};\n" +
            "      struct random_access_iterator_tag:public bidirectional_iterator_tag{};\n" +
            "      ```\n" +
            "  * 重新设计上述“<a href=\"#max_efficiency\" id=\"only_call\">提供最大效率</a>”的advance（）：\n" +
            "    ```\n" +
            "    //函数第三个参数只用来激活重载机制，其他的什么也不做\n" +
            "    template <class InputIterator,class Distance>\n" +
            "    inline void __advance(InputIterator & i,Distance n,input_iterator_tag)\n" +
            "    {\n" +
            "      //单向，逐一前进\n" +
            "      while(n--)++i;\n" +
            "    }\n" +
            "\n" +
            "    template <class ForwordIterator,class Distance>\n" +
            "    inline void __advance(ForwordIterator & i,Distance n,forword_iterator_tag)\n" +
            "    {\n" +
            "      //单纯的传递调用\n" +
            "      _advance(i,n,input_iterator_tag());\n" +
            "    }\n" +
            "\n" +
            "    template <class InputIterator,class Distance>\n" +
            "    inline void __advance(BidirectionalIterator & i,Distance n,bidirectional_iterator_tag)\n" +
            "    {\n" +
            "      //双向，逐一前进\n" +
            "      if(n>=0)\n" +
            "        while(n--)++i;\n" +
            "      else\n" +
            "        while(n++)--i;\n" +
            "    }\n" +
            "\n" +
            "    template <class RandomAccessIterator,class Distance>\n" +
            "    inline void __advance(RandomAccessIterator & i,Distance n,random_access_iterator_tag)\n" +
            "    {\n" +
            "      //双向，跳跃前进\n" +
            "      i += n;\n" +
            "    }\n" +
            "    ```\n" +
            "    - 到此，还需要一个对外开放的上层控制接口，调用各个重载函数__advance()。这一上层接口只需要两个参数，当这一接口准备将工作转给上述的__advance()时，才自行加上**第三个参数：迭代器类型**。\n" +
            "    - 这个上层接口必须有能力从它所获得的迭代器中推导出其类型（利用traits机制）：\n" +
            "      ```\n" +
            "      template <class InputIterator,class Distance>\n" +
            "      inline void advance(InputIterator& i,Distance n)\n" +
            "      {\n" +
            "        //iterator_traits<InputIterator>::iterator_catagory()将产生一个暂时对象（如int()）\n" +
            "        //其型别对应于前述四个迭代器（I,F,B,R）\n" +
            "        __advance(i,n,iterator_traits<InputIterator>::iterator_catagory());\n" +
            "      }\n" +
            "      ```\n" +
            "      为了满足上述行为，traits必须再增加一个相应的型别\n" +
            "      ```\n" +
            "      template<class I>\n" +
            "      struct iterator_traits{\n" +
            "        ···\n" +
            "        typedef typename I::iterator_catagory iterator_catagory;\n" +
            "      };\n" +
            "\n" +
            "      //针对原生指针而设计的“偏特化的版本”,原生指针是一种Random Access Iterator\n" +
            "      template<class T>\n" +
            "      struct iterator_traits<T*>{\n" +
            "        ···\n" +
            "        typedef random_access_iterator_tag iterator_catagory;\n" +
            "      };\n" +
            "\n" +
            "      //针对pointer-to-const而设计的“偏特化版本”\n" +
            "      template<class T>\n" +
            "      struct iterator_traits<const T*>{\n" +
            "        ···\n" +
            "        typedef random_access_iterator_tag iterator_catagory;\n" +
            "      };\n" +
            "      ```\n" +
            "  * 仔细观察advance()既然可以接受各种类型的迭代器，就不应该将其型别参数命名为InputIterator。\n" +
            "    ```\n" +
            "    template <class InputIterator,class Distance>\n" +
            "    inline void advance(InputIterator& i,Distance n);\n" +
            "    ```\n" +
            "    这是STL算法的一个命名规则：**以算法所能接受之最低阶迭代器类型，来为迭代器型别参数命名**。\n" +
            "  * 消除“<a href=\"#only_call\">单纯传递调用的函数</a>”(上述advance() ForwordIterator版)\n" +
            "    >以class来定义迭代器的各种分类标签，不仅可以促成重载机制的成功运作，另一个好处是，通过继承，我们可以不必写“单纯只做传递调用”的函数。\n" +
            "    ```\n" +
            "    #include<iostream>\n" +
            "    using namespace std;\n" +
            "\n" +
            "    struct B{};\n" +
            "    struct D1 : public B{};\n" +
            "    struct D2 : public D1{};\n" +
            "\n" +
            "    template <class I>\n" +
            "    func(I& p,B)\n" +
            "    {cout<<\"B version\"<<endl;}\n" +
            "\n" +
            "    template<class I>\n" +
            "    func(I& p,D2)\n" +
            "    {cout<<\"D2 version\"<<endl;}\n" +
            "\n" +
            "    int main()\n" +
            "    {\n" +
            "      int * p;\n" +
            "      func(p,B());//参数完全吻合。输出：“B version”\n" +
            "      func(p,D1());//参数未能完全吻合；因继承关系而转自动调用，输出“B version”；\n" +
            "      func(p,D2()); //参数完全吻合。输出：\"D2 version\";\n" +
            "    }\n" +
            "    ```\n" +
            "\n" +
            "#### 3.5 std::iterator的保证\n" +
            "  * std::iterator关于对用户自定义iterator的规定\n" +
            "    >为了符合规范，任何迭代器都应该提供五个内嵌相应型别，以利于**traits**萃取，否则便是自别于整个STL架构，无法与其他组件顺利搭配。\n" +
            "\n" +
            "    STL提供了一个iterators class如下，如果每个新设计的迭代器都继承自它，就可保证符合STL所需之规范：\n" +
            "    ```\n" +
            "    template<class Category,\n" +
            "             class T,\n" +
            "             class Distance = ptrdiff_t,\n" +
            "             class Pointer = T*,\n" +
            "             class Reference = T&>\n" +
            "    struct iterator{\n" +
            "      typedef Category iterator_catagory;\n" +
            "      typedef T value_type;\n" +
            "      typedef Distance difference_type;\n" +
            "      typedef Pointer pointer;\n" +
            "      typedef Reference reference;\n" +
            "    }\n" +
            "    ```\n" +
            "  * 迭代器负责设计适当的相应的型别。容器负责设计适当的迭代器。算法独立于容器和迭代器之外，只要设计时以迭代器为对外接口就行。\n" +
            "  * **traits**编程技法大量运用于STL实现品中。\n" +
            "    >它利用“内嵌型别”的编程技巧与编译器的template参数推导功能，增强C++未能提供的关于型别认证方面的能力，弥补C++不为强型别语言的遗憾。\n" +
            "\n" +
            "#### 3.6 iterator源代码完整序列\n" +
            "\n" +
            "  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128172449518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128172514291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112817254268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            "#### 3.7 SGI STL的私房菜：__type_traits\n" +
            "  * traits编程技法适度弥补了C++语言本身的不足。STL只对迭代器加一规范，制定出iterator_traits。SGI把这种技法进一步扩大到迭代器以外的世界，于是就有了__type_traits。（不再STL标准，在SGI STL内部）\n" +
            "  * iterator_traits负责萃取迭代器的特性，__type_traits则负责萃取型别的特性。\n" +
            "    - 此处我们所关注的型别特性是指：这个型别是否具备：\n" +
            "      + non-trivial default ctor(不是无用的构造函数)\n" +
            "      + non-trivial copy ctor(不是无用的赋值构造函数)\n" +
            "      + non-trivial assignment operator(不是无用的赋值重载函数)\n" +
            "      + non-trivial dtor(不是无用的析构函数)\n" +
            "    - 如果答案是否定的，我们在对这个型别进行构造、拷贝、赋值、析构等操作时，就可以采用最优效率的措施。\n" +
            "  * 定义于SGI<type_traits.h>中的__type_traits,提供了一种机制，允许不同的型别属性，在编译时期完成函数派送决定。\n" +
            "    - 根据iterator_traits的来的经验，我们希望，程序中可以这样运用__type_traits<T>,T为任意类别：\n" +
            "      ```\n" +
            "      __type_traits<T>::has_trivial_default_constructor;\n" +
            "      __type_traits<T>::has_trivial_copy_constructor;\n" +
            "      __type_traits<T>::has_trivial_assignment_operator;\n" +
            "      __type_traits<T>::has_trivial_destructor;\n" +
            "      __type_traits<T>::is_POD_type;\n" +
            "      ```\n" +
            "    - 我们希望利用其响应结果来进行参数推导，所以其结果应该是个有着真假值的“对象”，所以设计如下：\n" +
            "      ```\n" +
            "      struct __true_type{};\n" +
            "      struct __false_type{};\n" +
            "      ```\n" +
            "  * 为了达成上述的五个式子，__type_traits内必须定义一些typedefs，其值不是__ture_type就是__false__type。下面给出SGI的做法：\n" +
            "    ```\n" +
            "    template <class type>\n" +
            "    struct __type_traits{\n" +
            "      typedef __true_type this_dummy_member_must_be_first;\n" +
            "      typedef __false_type has_trivial_default_constructor;\n" +
            "      typedef __false_type has_trivial_copy_constructor;\n" +
            "      typedef __false_type has_trivial_assignment_operator;\n" +
            "      typedef __false_type has_trivial_destructor;\n" +
            "      typedef __false_type is_POD_type;\n" +
            "    }\n" +
            "    ```\n" +
            "  * <type_traits.h>对所有C++标量性别所定义的__type_traits特化版本\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019112817261087.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128172630240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            " ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191128172653294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNzYyODYxNzk0,size_16,color_FFFFFF,t_70)\n" +
            " #### 总结\n" +
            " * STL中的**iterator**就是利用“**内嵌型别**”的编程技巧和编译器的template参数推导功能，来实现作为STL中算法和容器的胶着剂。我们可以把迭代器视为一个广义的指针（或者智能指针），其中最重要的就是**operator***和**operator->**重载。\n" +
            " * 为了实现对容器template的更好的贴合，迭代器规定内部必须含有特定的五个型别：\n" +
            " \t- iterator_category\n" +
            " \t- value_type\n" +
            " \t- difference_type\n" +
            " \t- pointer\n" +
            " \t- reference\n" +
            " \t为了可以支持原始指针作为一种迭代器，STL新引入了**iterator_traits**，实现对原始指针可能的“偏特化版本”。\n" +
            " * 目前STL内部有五种迭代器类别，不同的迭代器同一个算法选择的实现会不一样（为了获得最大效率）\n" +
            " \t- **Input Iterator**:这种迭代器所指对象，不允许外界改变。只读。\n" +
            "    - **Output Iterator**：只写。\n" +
            "    - **Forword Iterator**：允许“写入型”算法( 例如replace（）)在这种迭代器所形成的区间上进行读写操作。\n" +
            "    - **Bidirectional Iterator**:可双向移动。\n" +
            "    - **Random Access Itertor**：最强大，涵盖前面所有迭代器的功能。\n" +
            "  * 迭代器分类后，可以利用traits特性萃取出当前迭代器类型，并选择最符合当前迭代器类型的同一算法下的不同实现，以达到最好效率。（通过函数重载）\n" +
            "  * 从**iterator_traits**扩展出的 __type_traits 可以萃取型别的特性。可以通过__type_traits判断对象是否有该判断属性，以便采用不同的策略，以提供更好的效能。\n" +
            "  <br>\n" +
            "  <hr>\n" +
            "\n" +
            "\n"};
}
